#!/usr/bin/env groovy
/* Build script for FIDATA Infrastructure
   Copyright Â© 2015-2018  Basil Peace

   This file is part of FIDATA Infrastructure.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied.
   See the License for the specific language governing permissions and
   limitations under the License. */

buildscript {
  configurations.classpath.resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
  repositories {
    maven {
      url 'https://fidata.jfrog.io/fidata/plugins-snapshot'
      credentials {
        username = artifactoryUser
        password = artifactoryPassword
      }
    }
  }
  dependencies {
    classpath 'gradle.plugin.fidata.org:gradle-packer-plugin:2.4.0'
    classpath 'com.amazonaws:aws-java-sdk-ec2:1.11.323'
    classpath 'org.apache.commons:commons-exec:1.3'
    classpath 'com.jcraft:jsch:0.1.54'
    configurations.classpath.exclude group: 'xerces', module: 'xercesImpl'
  }
}

plugins {
  id 'eclipse'
  id 'com.github.ben-manes.versions' version '0.17.0'
  id 'nebula.dependency-lock' version '5.0.4'
  id 'com.github.jlouns.cpe' version '0.5.0'
  id 'com.jfrog.artifactory' version '4.7.2'
  id 'codenarc'
  id 'cz.malohlava' version '1.0.3'
}

apply plugin: 'org.fidata.packer'

artifactory {
  contextUrl = 'http://fidata.jfrog.io/fidata'
  resolve {
    repository {
      repoKey = 'libs-snapshot'
      username = artifactoryUser
      password = artifactoryPassword
      maven = true
    }
  }
}

import org.gradle.internal.os.OperatingSystem
import java.util.regex.*
import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import org.apache.commons.exec.*
import com.jcraft.jsch.*
import org.apache.commons.io.filefilter.DirectoryFileFilter
import com.amazonaws.services.ec2.AmazonEC2ClientBuilder
import com.amazonaws.auth.AWSStaticCredentialsProvider
import com.amazonaws.auth.BasicAWSCredentials
import com.amazonaws.services.ec2.model.DescribeImagesRequest
import com.amazonaws.services.ec2.model.Filter
import com.amazonaws.services.ec2.model.Image

task wrapper(type: Wrapper) {
  gradleVersion = '4.7'
}

LogLevel logLevel = (logging.level ?: gradle.startParameter.logLevel)

ext.with {
  bundleExecutable = OperatingSystem.current().windows ? 'bundle.bat' : 'bundle'
  bundleLogLevelArgs = [].with {
    if (logLevel <= LogLevel.INFO) {
      push '--verbose'
    }
    it
  }
  pipenvLogLevelArgs = [].with {
    if (logLevel <= LogLevel.INFO) {
      push '--verbose'
    }
    it
  }
  rubyLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: push '--debug'
      case { it <= LogLevel.INFO }: push '-W2'; break
      case { it >= LogLevel.QUIET }: push '-W0'; break
    }
    it
  }
  berksLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: push '--debug'; break
      case { it >= LogLevel.QUIET }: push '--quiet'; break
    }
    it
  }
  berksEnvironment = [
    'ARTIFACTORY_API_KEY': artifactoryPassword,
  ]
  knifeLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.INFO }: push '--verbose'
      case { it <= LogLevel.DEBUG }: push '--verbose'
    }
    it
  }
  String kitchenLogLevel = {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: 'debug'; break
      case { it <= LogLevel.LIFECYCLE }: 'info'; break
      case { it <= LogLevel.WARN }: 'warn'; break
      case { it <= LogLevel.ERROR }: 'error'; break
      default: 'fatal'
    }
  }()
  kitchenLogLevelArgs = ["--log-level=$kitchenLogLevel"]
  String terraformLogLevel = {
    if (gradle.startParameter.showStacktrace >= ShowStacktrace.ALWAYS) {
      return 'TRACE'
    }
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: 'DEBUG'; break
      case { it <= LogLevel.INFO }: 'INFO'; break
      case { it <= LogLevel.WARN }: 'WARN'; break
      case { it <= LogLevel.ERROR }: 'ERROR'; break
    }
  }()
  terraformEnvironment = [
    'ARTIFACTORY_USERNAME': artifactoryUser,
    'ARTIFACTORY_PASSWORD': artifactoryPassword,
  ]
  if (terraformLogLevel != null) {
    terraformEnvironment['TF_LOG'] = terraformLogLevel
  }

  consoleExecutable = OperatingSystem.current().windows ? 'cmd' : '/usr/bin/x-terminal-emulator'
  consoleArgs = OperatingSystem.current().windows ? ['/c', 'start', 'cmd', '/k']: ['--disable-factory', '-e']

  gemfile = file('gems.rb')
  gemfileLock = file('gems.locked')
  chefVersion = file("$buildDir/chef_version")
  libDir = file('src/lib')
  videocaptureDir = file("$buildDir/videocapture")
  vboxOutputDir = file("$buildDir/vbox")
  vagrantOutputDir = file("$buildDir/vagrant")
  manifestOutputDir = file("$buildDir/manifest")
  chefDir = file('src/chef')
  berksfile = file("$chefDir/Berksfile")
  berksfileLock = file("$chefDir/Berksfile.lock")
  berksVendorDir = file("$buildDir/berks-cookbooks")
  vagrantDir = file('src/vagrant')
  terraformDir = file('src/terraform')
  terraformOutputDir = file("$buildDir/terraform")
  encryptedDataBagSecret = file(encryptedDataBagSecret)
  keysDir = file("$buildDir/keys")
  fidataMainSSHPrivateKey = file("$keysDir/fidata-main")
  fidataChefSSHPrivateKey = file("$keysDir/fidata-chef")
  fidataJenkinsSSHPrivateKey = file("$keysDir/fidata-jenkins")
  kitchenSSHPrivateKey = file("$keysDir/kitchen")
  chefIdPrivateKey = file(chefIdPrivateKey)
  reportsDir = file("$buildDir/reports")
  xmlReportsDir = file("$reportsDir/xml")
  codenarcXMLOutput = file("$xmlReportsDir/codenarc.xml")
  checkstyleReportsDir = file("$reportsDir/checkstyle")
  rubocopCheckstyleOutput = file("$checkstyleReportsDir/rubocop.xml")
  cookstyleCheckstyleOutput = file("$checkstyleReportsDir/cookstyle.xml")
  htmlReportsDir = file("$reportsDir/html")
  codenarcHTMLOutput = file("$htmlReportsDir/codenarc.html")
  rubocopHTMLOutput = file("$htmlReportsDir/rubocop.html")
  cookstyleHTMLOutput = file("$htmlReportsDir/cookstyle.html")

  terraformDirs = Arrays.asList(terraformDir.listFiles((FileFilter)DirectoryFileFilter.DIRECTORY))
}

visteg {
  enabled        = (logging.level ?: gradle.startParameter.logLevel) <= LogLevel.INFO
  colouredNodes  = true
  colouredEdges  = true
  destination    = "$reportsDir/visteg.dot"
  exporter       = 'dot'
  colorscheme    = 'paired12'
  nodeShape      = 'box'
  startNodeShape = 'hexagon'
  endNodeShape   = 'doubleoctagon'
}

boolean bundleDoctor() {
  exec({
    commandLine(
      [
        bundleExecutable, 'doctor'
      ] +
      bundleLogLevelArgs
    )
    ignoreExitValue = true
  }).exitValue == 0
}

task('bundleInstall') {
  inputs.file gemfile
  doLast {
    exec {
      commandLine(
        [
          bundleExecutable, 'install'
        ] +
        bundleLogLevelArgs
      )
    }
  }
  outputs.with {
    file gemfileLock
    upToDateWhen { bundleDoctor() }
  }
}

task('buildToolsInstall') {
  group 'Build Setup'
  dependsOn 'bundleInstall'
  doLast {
    exec {
      workingDir chefDir
      environment << berksEnvironment
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'install'
        ] +
        berksLogLevelArgs
      )
    }
    exec {
      environment << ['PIPENV_TIMEOUT': 300]
      commandLine(
        [
          'pipenv', 'install',
          '--dev'
        ] +
        (
          OperatingSystem.current().windows ?
          ['--python', '3'] :
          ['--three']
        ) +
        pipenvLogLevelArgs
      )
    }
    terraformDirs.each { d ->
      exec {
        workingDir d
        environment << terraformEnvironment
        commandLine(
          [
            'terraform', 'init',
            '-input=false'
          ]
        )
      }
    }
  }
}

task('buildToolsOutdated') {
  group 'Build Setup'
  dependsOn 'dependencyUpdates'
  doLast {
    exec {
      commandLine(
        [
          bundleExecutable, 'outdated'
        ] +
        bundleLogLevelArgs
      )
      ignoreExitValue true
    }
    exec {
      commandLine(
        [
          'pipenv', 'update', '--dry-run',
          '--dev'
        ] +
        pipenvLogLevelArgs
      )
      ignoreExitValue true
    }
    exec {
      workingDir chefDir
      environment << berksEnvironment
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'outdated'
        ] +
        berksLogLevelArgs
      )
      ignoreExitValue true
    }
  }
}

void bundleUpdate(List<String> gems = []) {
  exec {
    commandLine(
      [
        bundleExecutable, 'update'
      ] +
      gems +
      bundleLogLevelArgs
    )
  }
}

void berksUpdate() {
  exec {
    workingDir chefDir
    environment << berksEnvironment
    commandLine(
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs +
      [
        'berks', 'update'
      ] +
      berksLogLevelArgs
    )
  }
}

task('buildToolsUpdate') {
  group 'Build Setup'
  mustRunAfter 'buildToolsInstall'
  dependsOn 'updateLock', 'saveLock', 'dependencyUpdates'
  doLast {
    bundleUpdate()
    berksUpdate()
    exec {
      commandLine(
        [
          'pipenv', 'update',
          '--dev'
        ] +
        pipenvLogLevelArgs
      )
    }
    terraformDirs.each { d ->
      exec {
        workingDir d
        environment << terraformEnvironment
        commandLine(
          [
            'terraform', 'init',
            '-input=false',
            '-upgrade=true'
          ]
        )
      }
    }
  }
}

afterEvaluate {
  tasks.each { t ->
    if (!(t.name =~ /^buildTools/)) {
      t.mustRunAfter 'buildToolsInstall'
      if (t.name != 'updateLock' && t.name != 'saveLock') {
        t.mustRunAfter 'updateLock', 'saveLock'
      }
      if (t.name != 'updateLock' && t.name != 'saveLock' && t.name != 'dependencyUpdates') {
        t.mustRunAfter 'buildToolsUpdate'
      }
    }
  }
}

task('getChefVersion') {
  dependsOn 'bundleInstall'
  inputs.file gemfile
  inputs.file gemfileLock
  doLast {
    new FileOutputStream(chefVersion).withStream { os ->
      exec {
        commandLine(
          [
            bundleExecutable, 'exec'
          ] +
          bundleLogLevelArgs +
          [
            'ruby'
          ] +
          rubyLogLevelArgs +
          [
            '--',
            "$libDir/get_gem_locked_version.rb",
            'get', 'chef'
          ]
        )
        standardOutput = os
      }
    }
  }
  outputs.file chefVersion
}

task('pipenvCheck', type: Exec) {
  group 'Test'
  commandLine(
    [
      'pipenv', 'check'
    ]
  )
}

ext.with {
  sshKeyType = KeyPair.RSA
  sshKeySize = 4096

  kitchenEnvironment = [
    'CHEF_VERSION': "${ -> chefVersion.text}",
    'AWS_ACCESS_KEY_ID': awsAccessKey,
    'AWS_SECRET_ACCESS_KEY': awsSecretKey,
    'KITCHEN_SSH_KEY': kitchenSSHPrivateKey.absolutePath,
    'ENCRYPTED_DATA_BAG_SECRET': encryptedDataBagSecret.absolutePath,
  ]

  Map terraformVariables = [
    'lib_dir': libDir.absolutePath,
    'keys_dir': keysDir.absolutePath,
    'aws_access_key': awsAccessKey,
    'aws_secret_key': awsSecretKey,
    'cloudflare_email': cloudflareEmail,
    'cloudflare_token': cloudflareToken,
  ]
  terraformVariablesForArgs = terraformVariables.collectMany { key, value -> ['-var', "$key=$value"] }

  awsSecurityGroups = [:]

  jenkinsSlaves = [
    'UbuntuServer-16.04.4+amd64': [
      'version': '0.3.2',
      'security_groups': ['default', 'ICMP_private', 'SSH'] as Set<String>,
      'type_data': [
        'type': 'unix',
        'root_Ñommand_prefix': ''
      ],
      'remote_admin': 'ubuntu',
      'remote_fs': '/srv/jenkins',
      'labels': ['ubuntu', 'amd64'] as Set<String>,
      'mode': 'NORMAL',
      'instance_cap': '2',
    ]
  ]

  terraformOutputs = [:].withDefault { [:] }

  dataBags = [
    'FIDATAChef': [:],
    'FIDATAJenkins': [:],
    'JenkinsGithubOAuth': [:],
    'JenkinsEC2Cloud': [:],
    'ReleaseCredentials': [:],
  ]

  ec2 = null
}

String findAMI(String name, String version) {
  ec2 = ec2 ?: AmazonEC2ClientBuilder.standard()
    .withCredentials(new AWSStaticCredentialsProvider(new BasicAWSCredentials(awsAccessKey, awsSecretKey)))
    .withRegion('eu-west-1')
    .build()
  List<Image> result = ec2.describeImages(new DescribeImagesRequest()
    .withFilters(
      new Filter('name', [name]),
      new Filter('tag:version', [version])
    )
    .withOwners('880042334380')
  ).images
  if (result.size() == 0) {
    logger.error(sprintf('findAMI: Can\'t find image with name: %s, version: %s', [name, version]))
  }
  else if (result.size() > 1) {
    logger.error(sprintf('findAMI: Too many images found with name: %s, version: %s', [name, version]))
  }
  else {
    return result[0].imageId
  }
}

task('createVideocaptureDir') {
  doLast {
    videocaptureDir.mkdirs()
  }
  outputs.upToDateWhen {
    videocaptureDir.exists()
  }
}

/* WORKAROUND:
   https://github.com/FIDATA/gradle-packer-plugin/issues/1
   <grv87 2018-04-17> */
task('createManifestOutputDir') {
  doLast {
    manifestOutputDir.mkdirs()
  }
  outputs.upToDateWhen {
    manifestOutputDir.exists()
  }
}

class GenerateSSHKeyTask extends DefaultTask {
  private final static JSch JSCH

  private File privateKeyFile
  private File publicKeyFile

  @OutputFile
  File getPrivateKeyFile() { privateKeyFile }
  void setPrivateKeyFile(File privateKeyFile) {
      this.privateKeyFile = privateKeyFile
      this.publicKeyFile = project.file("${privateKeyFile}.pub")
  }
  @OutputFile
  File getPublicKeyFile() { publicKeyFile }

  int keyType
  int keySize
  String email

  static {
    JSCH = new JSch()
  }

  @TaskAction
  void generate() {
    if (!privateKeyFile.exists() || !publicKeyFile.exists()) {
      KeyPair kpair = KeyPair.genKeyPair(JSCH, keyType, keySize)
      kpair.writePrivateKey(privateKeyFile.path)
      kpair.writePublicKey(publicKeyFile.path, email)
      kpair.dispose()
    }
  }
}

task('generateSSHKey-FIDATAMain', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataMainSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataMainEmail
}

task('generateSSHKey-FIDATAChef', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataChefSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataChefEmail
}

task('generateSSHKey-FIDATAJenkins', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataJenkinsSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataJenkinsEmail
}

task('generateSSHKey-Kitchen', type: GenerateSSHKeyTask) {
  privateKeyFile = kitchenSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataKitchenEmail
}

task('terraformValidate-common', type: Exec) {
  inputs.with {
    property 'terraformVariablesForArgs', terraformVariablesForArgs
    files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
  }
  workingDir "$terraformDir/common"
  environment << terraformEnvironment
  commandLine(
    [
      'terraform', 'validate'
    ] +
    terraformVariablesForArgs
  )
}

task('terraformDestroy-common') {
  mustRunAfter 'terraformValidate-common'
  inputs.with {
    inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
    inputs.files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
  }
  File outputFile = file("$terraformOutputDir/common.json")
  doLast {
    exec {
      workingDir "$terraformDir/common"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'destroy',
          '-auto-approve',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
    outputFile.delete()
  }
}

task('createTerraformOutputDir') {
  doLast {
    terraformOutputDir.mkdirs()
  }
  outputs.upToDateWhen {
    terraformOutputDir.exists()
  }
}

task('terraformApply-common') {
  group 'Build'
  dependsOn 'generateSSHKey-FIDATAMain', 'generateSSHKey-Kitchen', 'generateSSHKey-FIDATAJenkins', 'createTerraformOutputDir'
  mustRunAfter 'terraformValidate-common', 'terraformDestroy-common'
  inputs.with {
    property 'terraformVariablesForArgs', terraformVariablesForArgs
    files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
    file tasks['generateSSHKey-FIDATAMain'].publicKeyFile
    file tasks['generateSSHKey-FIDATAJenkins'].publicKeyFile
    file tasks['generateSSHKey-Kitchen'].publicKeyFile
  }
  File outputFile = file("$terraformOutputDir/common.json")
  doLast {
    exec {
      workingDir "$terraformDir/common"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'apply',
          '-input=false',
          '-auto-approve',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
    new FileOutputStream(outputFile).withStream { os ->
      exec {
        workingDir "$terraformDir/common"
        environment << terraformEnvironment
        commandLine([
          'terraform', 'output',
          '-json'
        ])
        standardOutput = os
      }
    }
  }
  outputs.file outputFile
}

task('parseTerraformOutput-common') {
  dependsOn 'terraformApply-common'
  File outputFile = file("$terraformOutputDir/common.json")
  inputs.file outputFile
  doLast {
    terraformOutputs << new JsonSlurper().parse(outputFile)
    kitchenEnvironment << [
      'AWS_SUBNET_ID': terraformOutputs['fidata_subnet_id']['value'],
    ]
    awsSecurityGroups << terraformOutputs.findResults({ key, value ->
      def m = key =~ /^(.+)_security_group_id$/
      if (m.matches()) {
          return [m[0][1], value['value']]
      }
    }).flatten().toSpreadMap()
    for (securityGroup in awsSecurityGroups) {
      kitchenEnvironment["AWS_${securityGroup.key.toUpperCase()}_SG_ID"] = securityGroup.value
    }
    jenkinsSlaves.values().each { slave ->
      slave['security_groups'] = slave['security_groups'].collect { awsSecurityGroups[it] } as Set<String>
    }
  }
}

packer {
  customVariables = [
    'chef_version': "${ -> chefVersion.text}",
    'chef_dir': chefDir,
    'berks_vendor_dir': berksVendorDir,
    'videocapture_dir': videocaptureDir,
    'vbox_output_dir': vboxOutputDir,
    'vagrant_output_dir': vagrantOutputDir,
    'manifest_output_dir': manifestOutputDir,
    'aws_access_key': awsAccessKey,
    'aws_secret_key': awsSecretKey,
    'vagrant_cloud_token': vagrantCloudToken,
    'encrypted_data_bag_secret': encryptedDataBagSecret,
  ]
  // Kernel images
  template 'src/packer/kernel_images/kernel-UbuntuServer-16.04.4+amd64.json'

  // Base images
  template 'src/packer/base_images/UbuntuServer-16.04.4+amd64.json'

  // Instances
  template 'src/packer/instances/JenkinsMaster.json'
  template 'src/packer/instances/JenkinsSlaves.json'
}

tasks['build-kernel-UbuntuServer-16.04.4+amd64-vbox'].dependsOn 'getChefVersion', 'createVideocaptureDir', 'createManifestOutputDir'
tasks['build-UbuntuServer-16.04.4+amd64-vbox'].dependsOn 'getChefVersion', 'createManifestOutputDir'
tasks['build-UbuntuServer-16.04.4+amd64-vbox'].mustRunAfter 'build-kernel-UbuntuServer-16.04.4+amd64-vbox'
tasks['build-UbuntuServer-16.04.4+amd64-amazon'].dependsOn 'getChefVersion', 'createManifestOutputDir'
tasks['build-UbuntuServer-16.04.4+amd64'].dependsOn 'getChefVersion', 'createManifestOutputDir'

task('clean-base') {
  group 'Build'
  dependsOn 'clean-UbuntuServer-16.04.4+amd64'
}

task('clean') {
  dependsOn 'clean-base', 'clean-JenkinsSlaves', 'clean-JenkinsMaster'
}

task('build-base-vbox') {
  group 'Build'
  dependsOn 'build-UbuntuServer-16.04.4+amd64-vbox'
}

task('build-base-amazon') {
  group 'Build'
  dependsOn 'build-UbuntuServer-16.04.4+amd64-amazon'
}

task('build-base') {
  group 'Build'
  dependsOn 'build-UbuntuServer-16.04.4+amd64'
}

task('berksUpdate') {
  doLast {
    berksUpdate()
  }
}

task('berksVerify') {
  inputs.file berksfile
  doLast {
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'verify'
        ] +
        berksLogLevelArgs
      )
    }
  }
}

task('berksClean', type: Delete) {
  delete berksVendorDir
}

task('berksVendor') {
  dependsOn 'berksClean', 'berksUpdate'
  mustRunAfter 'berksVerify'
  inputs.file berksfileLock
  doLast {
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'vendor',
          berksVendorDir.absolutePath
        ] +
        berksLogLevelArgs
      )
    }
  }
  outputs.dir berksVendorDir
}

task('kitchenTest-BuildToolset', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common', 'berksUpdate'
  mustRunAfter 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'test',
      'BuildToolset',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-BuildToolset', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common'
  mustRunAfter 'berksUpdate', 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'converge',
      'BuildToolset',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenLogin-BuildToolset') {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common'
  mustRunAfter 'kitchenConverge-BuildToolset'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'BuildToolset',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenVerify-BuildToolset', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common', 'kitchenConverge-BuildToolset'
  mustRunAfter 'berksUpdate', 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'verify',
      'BuildToolset',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-BuildToolset', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'BuildToolset',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

tasks['build-JenkinsSlaves'].with {
  dependsOn 'getChefVersion', 'createManifestOutputDir', 'terraformApply-common', 'parseTerraformOutput-common', 'berksVendor'
  mustRunAfter 'build-base', 'build-base-amazon', 'kitchenTest-BuildToolset', 'kitchenConverge-BuildToolset'
}

task('generateRuntimeDataBag') {
  dependsOn 'parseTerraformOutput-common', 'generateSSHKey-FIDATAChef', 'generateSSHKey-FIDATAJenkins'
  mustRunAfter 'build-JenkinsSlaves'
  inputs.with {
    file encryptedDataBagSecret
    property 'FIDATAChefDataBag', {
      dataBags['FIDATAChef'] << [
        'username': fidataChefUsername,
        'full_name': fidataChefFullName,
        'email': fidataChefEmail,
        'public_key': tasks['generateSSHKey-FIDATAChef'].publicKeyFile.text,
        'private_key': tasks['generateSSHKey-FIDATAChef'].privateKeyFile.text,
        'jenkins': [
          'password': fidataChefJenkinsPassword,
        ],
      ]
    }
    property 'FIDATAJenkinsDataBag', {
      dataBags['FIDATAJenkins'] << [
        'username': fidataJenkinsUsername,
        'full_name': fidataJenkinsFullName,
        'email': fidataJenkinsEmail,
        'public_key': tasks['generateSSHKey-FIDATAJenkins'].publicKeyFile.text,
        'private_key': tasks['generateSSHKey-FIDATAJenkins'].privateKeyFile.text,
        'yandex': [
          'username': fidataJenkinsYandexUsername,
          'password': fidataJenkinsYandexPassword,
        ],
        'github': [
          'token': fidataJenkinsGithubToken,
        ],
        'artifactory': [
          'api_key': fidataJenkinsArtifactoryAPIKey,
        ],
        'bintray': [
          'api_key': fidataJenkinsBintrayAPIKey,
        ],
        'aws_iam': [
          'access_key': terraformOutputs['fidata_jenkins_iam_access_key']['value'],
          'secret_key': terraformOutputs['fidata_jenkins_iam_secret_key']['value'],
        ],
      ]
    }
    property 'JenkinsGithubOAuthDataBag', {
      dataBags['JenkinsGithubOAuth'] << [
        'client_id': jenkinsGithubOAuthClientID,
        'client_secret': jenkinsGithubOAuthClientSecret,
      ]
    }
    property 'JenkinsEC2CloudDataBag', {
      for (s in jenkinsSlaves) {
        s.value['ami'] = findAMI("JenkinsSlave-${s.key.replace('+', '_')}-*".toString(), s.value['version'].toString())
      }
      dataBags['JenkinsEC2Cloud'] << [
        'region': 'eu-west-1',
        'zone': 'eu-west-1c',
        'subnet_id': terraformOutputs['fidata_subnet_id']['value'],
        'slaves': jenkinsSlaves,
      ]
    }
    property 'ReleaseCredentialsDataBag', {
      dataBags['ReleaseCredentials'] << [
        'rubygems': [
          'api_key': rubygemsAPIKey,
        ],
        'pypi': [
          'username': pypiUsername,
          'password': pypiPassword,
        ],
        'gradle_plugins': [
          'key': gradlePluginsKey,
          'secret': gradlePluginsSecret,
        ],
        'chocolatey': [
          'api_key': chocolateyAPIKey,
        ],
        'chef_id': [
          'private_key': chefIdPrivateKey.text,
        ],
      ]
    }
  }

  doLast {
    for (dataBag in dataBags) {
      exec {
        workingDir chefDir
        commandLine(
          [
            bundleExecutable, 'exec'
          ] +
          bundleLogLevelArgs +
          [
            'knife', 'solo', 'data', 'bag', 'create',
            'runtime', dataBag.key,
            '--secret-file', encryptedDataBagSecret,
            '--json', JsonOutput.toJson(
              ['id': dataBag.key] +
              dataBag.value
            ).replace('"', OperatingSystem.current().windows ? '\\"' : '"')
          ] +
          knifeLogLevelArgs
        )
      }
    }
  }

  for (dataBag in dataBags) {
    outputs.file "$chefDir/data_bags/runtime/${dataBag.key}.json"
  }
}

task('kitchenTest-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common', 'generateRuntimeDataBag', 'berksUpdate'
  mustRunAfter 'build-UbuntuServer-16.04.4+amd64-vbox'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'test',
      'JenkinsMaster-vbox',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenTest-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common', 'generateRuntimeDataBag', 'berksUpdate'
  mustRunAfter 'build-UbuntuServer-16.04.4+amd64-amazon', 'build-UbuntuServer-16.04.4+amd64'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'test',
      'JenkinsMaster-amazon',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common', 'generateRuntimeDataBag'
  mustRunAfter 'berksUpdate', 'build-UbuntuServer-16.04.4+amd64-vbox'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'converge',
      'JenkinsMaster-vbox',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'terraformApply-common', 'parseTerraformOutput-common', 'generateRuntimeDataBag'
  mustRunAfter 'berksUpdate', 'build-UbuntuServer-16.04.4+amd64-amazon', 'build-UbuntuServer-16.04.4+amd64'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'converge',
      'JenkinsMaster-amazon',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenLogin-JenkinsMaster-vbox') {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  mustRunAfter 'kitchenConverge-JenkinsMaster-vbox'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'JenkinsMaster-vbox',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenLogin-JenkinsMaster-amazon') {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  mustRunAfter 'kitchenConverge-JenkinsMaster-amazon'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'JenkinsMaster-amazon',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'JenkinsMaster-vbox',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'JenkinsMaster-amazon',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

tasks['build-JenkinsMaster'].with {
  dependsOn 'getChefVersion', 'createManifestOutputDir', 'terraformApply-common', 'parseTerraformOutput-common', 'generateRuntimeDataBag', 'berksVendor'
  mustRunAfter 'build-UbuntuServer-16.04.4+amd64-amazon', 'build-UbuntuServer-16.04.4+amd64', 'kitchenTest-JenkinsMaster-vbox', 'kitchenConverge-JenkinsMaster-vbox', 'kitchenTest-JenkinsMaster-amazon', 'kitchenConverge-JenkinsMaster-amazon'
}

task('terraformValidate-instances', type: Exec) {
  inputs.with {
    property 'terraformVariablesForArgs', terraformVariablesForArgs
    files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  }
  workingDir "$terraformDir/instances"
  environment << terraformEnvironment
  commandLine(
    [
      'terraform', 'validate'
    ] +
    terraformVariablesForArgs
  )
}

task('terraformDestroy-instances') {
  mustRunAfter 'terraformValidate-instances'
  inputs.with {
    property 'terraformVariablesForArgs', terraformVariablesForArgs
    files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  }
  doLast {
    exec {
      workingDir "$terraformDir/instances"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'destroy',
          '-auto-approve',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
}

task('terraformApply-instances') {
  group 'Build'
  mustRunAfter 'terraformValidate-instances', 'terraformDestroy-instances', 'build-JenkinsMaster'
  inputs.with {
    property 'terraformVariablesForArgs', terraformVariablesForArgs
    files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  }
  doLast {
    exec {
      workingDir "$terraformDir/instances"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'apply',
          '-input=false',
          '-auto-approve',
          '-auto-approve',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
  outputs.upToDateWhen { false }
}

task('codenarc', type: CodeNarc) {
  group 'Test'
  source 'Jenkinsfile'
  source 'build.gradle'
  for (f in new FileNameFinder().getFileNames(projectDir.path, '**/*.groovy')) {
    source f
  }
  configFile = file('config/codenarc/codenarc.groovy')
  reports {
    xml {
      enabled = true
      destination = codenarcXMLOutput
    }
    console { enabled = true }
    html {
      enabled = true
      destination = codenarcHTMLOutput
    }
  }
}

task('kitchenDiagnose', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'getChefVersion', 'parseTerraformOutput-common'
  outputs.upToDateWhen { false }
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'diagnose',
      '--no-instances', '--all'
    ] +
    kitchenLogLevelArgs
  )
}

task('rubocop', type: CrossPlatformExec) {
  group 'Test'
  List<File> sourceFiles = [gemfile, libDir] + (new FileNameFinder().getFileNames(chefDir.path, '**/*.rb', 'cookbooks/**/* site-cookbooks/**/* environments/**/*')).collect { file(it) }
  for (f in sourceFiles) {
    inputs.with {
      if (f.isDirectory()) {
        files new FileNameFinder().getFileNames(f.path, '**/*.rb')
      }
      else {
        file f
      }
    }
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'rubocop',
      '--display-cop-names',
      '--require', 'rubocop/formatter/checkstyle_formatter',
      '--format', 'RuboCop::Formatter::CheckstyleFormatter', '--out', rubocopCheckstyleOutput.absolutePath,
      '--format', 'progress',
      '--format', 'html', '--out', rubocopHTMLOutput.absolutePath
    ] +
    sourceFiles
  )
  outputs.file rubocopCheckstyleOutput
  outputs.file rubocopHTMLOutput
}

task('foodcritic', type: CrossPlatformExec) {
  group 'Test'
  inputs.with {
    dir "$chefDir/cookbooks"
    dir "$chefDir/site-cookbooks"
    dir "$chefDir/environments"
  }
  workingDir chefDir
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'foodcritic',
      '--cookbook-path', 'cookbooks', 'site-cookbooks',
      '--environment-path', 'environments'
    ]
  )
}

task('cookstyle', type: CrossPlatformExec) {
  group 'Test'
  inputs.dir chefDir
  workingDir chefDir
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'cookstyle',
      '--display-cop-names',
      '--require', 'rubocop/formatter/checkstyle_formatter',
      '--format', 'RuboCop::Formatter::CheckstyleFormatter', '--out', cookstyleCheckstyleOutput.absolutePath,
      '--format', 'progress',
      '--format', 'html', '--out', cookstyleHTMLOutput.absolutePath
    ]
  )
  outputs.file cookstyleCheckstyleOutput
  outputs.file cookstyleHTMLOutput
}

task('check-noSideEffects') {
  group 'Test'
  dependsOn 'codenarc', 'pipenvCheck', 'berksVerify', 'validate', 'rubocop', 'foodcritic', 'cookstyle', 'terraformValidate-common', 'terraformValidate-instances'
}

/* CAVEAT:
 * kitchenDiagnose depends on terraformCommon-apply task
 * So we treat it separately <> */
task('check') {
  group 'Test'
  dependsOn 'check-noSideEffects', 'kitchenDiagnose'
}

task('deploy') {
  group 'Build'
  dependsOn 'terraformApply-instances'
}

task('inputsOutputs').doLast {
  for (t in tasks) {
    if (t.inputs.hasInputs) {
      for (f in t.inputs.files) {
        logger.lifecycle(sprintf('%s input:\t%s', [t.name, f.path]))
      }
    }
    if (t.outputs.hasOutput) {
      for (f in t.outputs.files) {
        logger.lifecycle(sprintf('%s output:\t%s', [t.name, f.path]))
      }
    }
  }
}
