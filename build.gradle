#!/usr/bin/env groovy
/* Build script for FIDATA Infrastructure
   Copyright Â© 2015-2018  Basil Peace

   This file is part of FIDATA Infrastructure.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied.
   See the License for the specific language governing permissions and
   limitations under the License. */

buildscript {
  configurations.classpath.resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
  repositories {
    maven {
      url 'https://fidata.jfrog.io/fidata/plugins-snapshot'
      credentials {
        username = artifactoryUser
        password = artifactoryPassword
      }
    }
  }
  dependencies {
    classpath 'gradle.plugin.fidata.org:gradle-packer-plugin:2.4.0'
    classpath 'org.apache.commons:commons-exec:1.3'
    classpath 'com.jcraft:jsch:0.1.54'
  }
}

plugins {
  id 'eclipse'
  id 'com.github.ben-manes.versions' version '0.17.0'
  id 'nebula.dependency-lock' version '5.0.4'
  id 'com.github.jlouns.cpe' version '0.5.0'
  id 'com.jfrog.artifactory' version '4.6.2'
  id 'codenarc'
  id 'cz.malohlava' version '1.0.3'
}

apply plugin: 'org.fidata.packer'

artifactory {
  contextUrl = 'http://fidata.jfrog.io/fidata'
  resolve {
    repository {
      repoKey = 'libs-snapshot'
      username = artifactoryUser
      password = artifactoryPassword
      maven = true
    }
  }
}

import org.gradle.internal.os.OperatingSystem
import java.util.regex.*
import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import org.apache.commons.exec.*
import com.jcraft.jsch.*

task wrapper(type: Wrapper) {
  gradleVersion = '4.6'
}

LogLevel logLevel = (logging.level ?: gradle.startParameter.logLevel)

ext.with {
  bundleExecutable = OperatingSystem.current().windows ? 'bundle.bat' : 'bundle'
  bundleLogLevelArgs = [].with {
    if (logLevel <= LogLevel.INFO) {
      push '--verbose'
    }
    it
  }
  pipenvLogLevelArgs = [].with {
    if (logLevel <= LogLevel.INFO) {
      push '--verbose'
    }
    it
  }
  rubyLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: push '--debug'
      case { it <= LogLevel.INFO }: push '-W2'; break
      case { it >= LogLevel.QUIET }: push '-W0'; break
    }
    it
  }
  berksLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: push '--debug'; break
      case { it >= LogLevel.QUIET }: push '--quiet'; break
    }
    it
  }
  knifeLogLevelArgs = [].with {
    switch (logLevel) {
      case { it <= LogLevel.INFO }: push '--verbose'
      case { it <= LogLevel.DEBUG }: push '--verbose'
    }
    it
  }
  String kitchenLogLevel = {
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: 'debug'; break
      case { it <= LogLevel.LIFECYCLE }: 'info'; break
      case { it <= LogLevel.WARN }: 'warn'; break
      case { it <= LogLevel.ERROR }: 'error'; break
      default: 'fatal'
    }
  }()
  kitchenLogLevelArgs = ["--log-level=$kitchenLogLevel"]
  String terraformLogLevel = {
    if (gradle.startParameter.showStacktrace >= ShowStacktrace.ALWAYS) {
      return 'TRACE'
    }
    switch (logLevel) {
      case { it <= LogLevel.DEBUG }: 'DEBUG'; break
      case { it <= LogLevel.INFO }: 'INFO'; break
      case { it <= LogLevel.WARN }: 'WARN'; break
      case { it <= LogLevel.ERROR }: 'ERROR'; break
    }
  }()
  terraformEnvironment = [:]
  if (terraformLogLevel != null) {
    terraformEnvironment['TF_LOG'] = terraformLogLevel
  }

  consoleExecutable = OperatingSystem.current().windows ? 'cmd' : '/usr/bin/x-terminal-emulator'
  consoleArgs = OperatingSystem.current().windows ? ['/c', 'start', 'cmd', '/k']: ['--disable-factory', '-e']

  gemfile = file('gems.rb')
  libDir = file('src/lib')
  videocaptureDir = file('build/videocapture')
  vboxOutputDir = file('build/vbox')
  vagrantOutputDir = file('build/vagrant')
  manifestOutputDir = file('build/manifest')
  chefDir = file('src/chef')
  berksfile = file("$chefDir/Berksfile")
  berksfileLock = file("$chefDir/Berksfile.lock")
  berksVendorDir = file('build/berks-cookbooks')
  vagrantDir = file('src/vagrant')
  terraformDir = file('src/terraform')
  terraformOutputDir = file('build/terraform')
  encryptedDataBagSecret = file(encryptedDataBagSecret)
  keysDir = file('build/keys')
  fidataMainSSHPrivateKey = file("$keysDir/fidata-main")
  fidataChefSSHPrivateKey = file("$keysDir/fidata-chef")
  fidataJenkinsSSHPrivateKey = file("$keysDir/fidata-jenkins")
  kitchenSSHPrivateKey = file("$keysDir/kitchen")
  chefIdPrivateKey = file(chefIdPrivateKey)
  reportsDir = file('build/reports')
  xmlReportsDir = file("$reportsDir/xml")
  codenarcXMLOutput = file("$xmlReportsDir/codenarc.xml")
  checkstyleReportsDir = file("$reportsDir/checkstyle")
  rubocopCheckstyleOutput = file("$checkstyleReportsDir/rubocop.xml")
  cookstyleCheckstyleOutput = file("$checkstyleReportsDir/cookstyle.xml")
  htmlReportsDir = file("$reportsDir/html")
  codenarcHTMLOutput = file("$htmlReportsDir/codenarc.html")
  rubocopHTMLOutput = file("$htmlReportsDir/rubocop.html")
  cookstyleHTMLOutput = file("$htmlReportsDir/cookstyle.html")

  terraformDirs = ["$libDir/get_atlas_artifact_metadata_full"]
  terraformDir.eachDir { d ->
    terraformDirs << d
  }
}

visteg {
  enabled        = (logging.level ?: gradle.startParameter.logLevel) <= LogLevel.INFO
  colouredNodes  = true
  colouredEdges  = true
  destination    = "$reportsDir/visteg.dot"
  exporter       = 'dot'
  colorscheme    = 'paired12'
  nodeShape      = 'box'
  startNodeShape = 'hexagon'
  endNodeShape   = 'doubleoctagon'
}

task('buildToolsInstall') {
  group 'Build Setup'
  doLast {
    exec {
      commandLine(
        [
          bundleExecutable, 'install'
        ] +
        bundleLogLevelArgs
      )
    }
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'install'
        ] +
        berksLogLevelArgs
      )
    }
    exec {
      workingDir chefDir
      commandLine(
        [
          'pipenv', 'install',
          '--dev'
        ] +
        (
          OperatingSystem.current().windows ?
          ['--python', '3'] :
          ['--three']
        ) +
        pipenvLogLevelArgs
      )
    }
    terraformDirs.each { d ->
      exec {
        workingDir d
        environment << terraformEnvironment
        commandLine(
          [
            'terraform', 'init',
            '-input=false'
          ]
        )
      }
    }
  }
}

task('buildToolsOutdated') {
  group 'Build Setup'
  dependsOn 'dependencyUpdates'
  doLast {
    exec {
      commandLine(
        [
          bundleExecutable, 'outdated'
        ] +
        bundleLogLevelArgs
      )
      ignoreExitValue true
    }
    exec {
      workingDir chefDir
      commandLine(
        [
          'pipenv', 'update', '--dry-run',
          '--dev'
        ] +
        pipenvLogLevelArgs
      )
      ignoreExitValue true
    }
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'outdated'
        ] +
        berksLogLevelArgs
      )
      ignoreExitValue true
    }
  }
}

void bundleUpdate(List<String> gems = []) {
  exec {
    commandLine(
      [
        bundleExecutable, 'update'
      ] +
      gems +
      bundleLogLevelArgs
    )
  }
}

void berksUpdate() {
  exec {
    workingDir chefDir
    commandLine(
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs +
      [
        'berks', 'update'
      ] +
      berksLogLevelArgs
    )
  }
}

task('buildToolsUpdate') {
  group 'Build Setup'
  mustRunAfter 'buildToolsInstall'
  dependsOn 'updateLock', 'saveLock', 'dependencyUpdates'
  doLast {
    bundleUpdate()
    berksUpdate()
    exec {
      workingDir chefDir
      commandLine(
        [
          'pipenv', '--update', 'update',
          '--dev'
        ] +
        pipenvLogLevelArgs
      )
    }
    terraformDirs.each { d ->
      exec {
        workingDir d
        environment << terraformEnvironment
        commandLine(
          [
            'terraform', 'init',
            '-input=false',
            '-upgrade=true'
          ]
        )
      }
    }
  }
}

afterEvaluate {
  tasks.each { t ->
    if (!(t.name =~ /^buildTools/)) {
      t.mustRunAfter 'buildToolsInstall'
      if (t.name != 'updateLock' && t.name != 'saveLock') {
        t.mustRunAfter 'updateLock', 'saveLock'
      }
      if (t.name != 'dependencyUpdates' && t.name != 'updateLock' && t.name != 'saveLock') {
        t.mustRunAfter 'buildToolsUpdate'
      }
    }
  }
}

new ByteArrayOutputStream().withStream { os ->
  exec {
    commandLine(
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs +
      [
        'ruby'
      ] +
      rubyLogLevelArgs +
      [
        '--',
        "$libDir/get_gem_locked_version.rb",
        'get', 'chef'
      ]
    )
    standardOutput = os
  }
  ext.chefVersion = os.toString()
}

task('bundleDoctor', type: CrossPlatformExec) {
  group 'Test'
  commandLine(
    [
      'bundle', 'doctor'
    ] +
    bundleLogLevelArgs
  )
}

task('pipenvCheck', type: Exec) {
  group 'Test'
  commandLine(
    [
      'pipenv', 'check'
    ]
  )
}

ext.with {
  sshKeyType = KeyPair.RSA
  sshKeySize = 4096

  kitchenEnvironment = [
    'CHEF_VERSION': chefVersion,
    'AWS_ACCESS_KEY_ID': awsAccessKey,
    'AWS_SECRET_ACCESS_KEY': awsSecretKey,
    'ATLAS_TOKEN': atlasToken,
    'KITCHEN_SSH_KEY': kitchenSSHPrivateKey.absolutePath,
    'ENCRYPTED_DATA_BAG_SECRET': encryptedDataBagSecret.absolutePath,
  ]

  Map terraformVariables = [
    'lib_dir': libDir.absolutePath,
    'keys_dir': keysDir.absolutePath,
    'aws_access_key': awsAccessKey,
    'aws_secret_key': awsSecretKey,
    'atlas_token': atlasToken,
    'cloudflare_email': cloudflareEmail,
    'cloudflare_token': cloudflareToken,
  ]
  terraformVariablesForArgs = terraformVariables.collectMany { key, value -> ['-var', "$key=$value"] }

  awsSecurityGroups = [
    'default': null,
    'SSH': null,
    'HTTP_S': null,
    'RDP': null,
    'SMB': null,
    'WinRM': null,
  ]

  jenkinsSlaves = [
    'UbuntuServer16.04.4+amd64': [
      'version': '0.3.1',
      'security_groups': ['SSH'] as Set<String>,
      'type_data': [
        'type': 'unix',
        'root_Ñommand_prefix': ''
      ],
      'remote_admin': 'ubuntu',
      'remote_fs': '/srv/jenkins',
      'labels': ['ubuntu', 'amd64'] as Set<String>,
      'mode': 'NORMAL',
      'instance_cap': '2',
    ]
  ]

  terraformOutputs = [:].withDefault { [:] }

  dataBags = [
    'FIDATAChef': [:],
    'FIDATAJenkins': [:],
    'JenkinsGithubOAuth': [:],
    'JenkinsEC2Cloud': [:],
    'ReleaseCredentials': [:],
  ]
}

Map getAtlasArtifactMetadataFull(name, type, version) {
  new ByteArrayOutputStream().withStream { os ->
    exec {
      environment([
        'ATLAS_TOKEN': atlasToken
      ])
      commandLine([
        bundleExecutable, 'exec',
        'ruby'
      ] +
      rubyLogLevelArgs +
      [
        '--',
        "$libDir/get_atlas_artifact_metadata_full/get_atlas_artifact_metadata_full.rb",
        'get',
        name, type, version
      ])
      standardOutput = os
    }
    new JsonSlurper().parseText(os.toString())
  }
}

task('createVideocaptureDir') {
  doLast {
    videocaptureDir.mkdirs()
  }
  outputs.upToDateWhen {
    videocaptureDir.exists()
  }
}

// BLOCKED: https://github.com/FIDATA/gradle-packer-plugin/issues/1 <>
task('createManifestOutputDir') {
  doLast {
    manifestOutputDir.mkdirs()
  }
  outputs.upToDateWhen {
    manifestOutputDir.exists()
  }
}

class GenerateSSHKeyTask extends DefaultTask {
  private final static JSch JSCH

  private File privateKeyFile
  private File publicKeyFile

  @OutputFile
  File getPrivateKeyFile() { privateKeyFile }
  void setPrivateKeyFile(File privateKeyFile) {
      this.privateKeyFile = privateKeyFile
      this.publicKeyFile = project.file("${privateKeyFile}.pub")
  }
  @OutputFile
  File getPublicKeyFile() { publicKeyFile }

  int keyType
  int keySize
  String email

  static {
    JSCH = new JSch()
  }

  @TaskAction
  void generate() {
    if (!privateKeyFile.exists() || !publicKeyFile.exists()) {
      KeyPair kpair = KeyPair.genKeyPair(JSCH, keyType, keySize)
      kpair.writePrivateKey(privateKeyFile.path)
      kpair.writePublicKey(publicKeyFile.path, email)
      kpair.dispose()
    }
  }
}

task('generateSSHKey-FIDATAMain', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataMainSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataMainEmail
}

task('generateSSHKey-FIDATAChef', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataChefSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataChefEmail
}

task('generateSSHKey-FIDATAJenkins', type: GenerateSSHKeyTask) {
  privateKeyFile = fidataJenkinsSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataJenkinsEmail
}

task('generateSSHKey-Kitchen', type: GenerateSSHKeyTask) {
  privateKeyFile = kitchenSSHPrivateKey
  keyType = sshKeyType
  keySize = sshKeySize
  email = fidataKitchenEmail
}

task('terraformValidate-common', type: Exec) {
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
  workingDir "$terraformDir/common"
  environment << terraformEnvironment
  commandLine(
    [
      'terraform', 'validate'
    ] +
    terraformVariablesForArgs
  )
}

task('terraformDestroy-common') {
  mustRunAfter 'terraformValidate-common'
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
  File stateFile = file("$terraformOutputDir/common.tfstate")
  doLast {
    exec {
      workingDir "$terraformDir/common"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'destroy',
          "-state=${stateFile.absolutePath}",
          '-force',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
  outputs.file stateFile
}

task('terraformApply-common') {
  group 'Build'
  dependsOn 'generateSSHKey-FIDATAMain', 'generateSSHKey-Kitchen', 'generateSSHKey-FIDATAJenkins'
  mustRunAfter 'terraformValidate-common', 'terraformDestroy-common'
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.with {
    files new FileNameFinder().getFileNames("$terraformDir/common", '*.tf *.tf.json')
    file tasks['generateSSHKey-FIDATAMain'].publicKeyFile
    file tasks['generateSSHKey-FIDATAJenkins'].publicKeyFile
    file tasks['generateSSHKey-Kitchen'].publicKeyFile
  }
  File stateFile = file("$terraformOutputDir/common.tfstate")
  doLast {
    exec {
      workingDir "$terraformDir/common"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'apply',
          '-input=false',
          "-state=${stateFile.absolutePath}",
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
  outputs.file stateFile
}

task('terraformOutput-common') {
  dependsOn 'terraformApply-common'
  mustRunAfter 'terraformValidate-common'
  File stateFile = file("$terraformOutputDir/common.tfstate")
  inputs.file stateFile
  doLast {
    new ByteArrayOutputStream().withStream { os ->
      exec {
        workingDir "$terraformDir/common"
        environment << terraformEnvironment
        commandLine([
          'terraform', 'output',
          "-state=${stateFile.absolutePath}",
          '-json'
        ])
        standardOutput = os
      }
      terraformOutputs << new JsonSlurper().parseText(os.toString())
    }
    kitchenEnvironment << [
      'AWS_SUBNET_ID': terraformOutputs['fidata_subnet_id']['value'],
    ]
    awsSecurityGroups << awsSecurityGroups.collectEntries { key, value ->
      [(key): terraformOutputs["${key}_security_group_id"]['value']]
    }
    for (securityGroup in awsSecurityGroups) {
      kitchenEnvironment["AWS_${securityGroup.key.toUpperCase()}_SG_ID"] = securityGroup.value
    }
    jenkinsSlaves.values().each { slave ->
      slave['security_groups'] = slave['security_groups'].collect { awsSecurityGroups[it] } as Set<String>
    }
  }
}

packer {
  customVariables = [
    'chef_version': chefVersion,
    'chef_dir': chefDir,
    'berks_vendor_dir': berksVendorDir,
    'videocapture_dir': videocaptureDir,
    'vbox_output_dir': vboxOutputDir,
    'vagrant_output_dir': vagrantOutputDir,
    'manifest_output_dir': manifestOutputDir,
    'aws_access_key': awsAccessKey,
    'aws_secret_key': awsSecretKey,
    'atlas_token': atlasToken,
    'vagrant_cloud_token': vagrantCloudToken,
    'encrypted_data_bag_secret': encryptedDataBagSecret,
  ]
  // Kernel images
  template 'src/packer/kernel_images/kernel-UbuntuServer16.04.4_amd64.json'

  // Base images
  template 'src/packer/base_images/UbuntuServer16.04.4_amd64.json'

  // Instances
  template 'src/packer/instances/JenkinsMaster.json'
  template 'src/packer/instances/JenkinsSlaves.json'
}

tasks['build-kernel-UbuntuServer16.04.4_amd64-vbox'].dependsOn 'createVideocaptureDir', 'createManifestOutputDir'
tasks['build-UbuntuServer16.04.4_amd64-vbox'].dependsOn 'createManifestOutputDir'
tasks['build-UbuntuServer16.04.4_amd64-vbox'].mustRunAfter 'build-kernel-UbuntuServer16.04.4_amd64-vbox'
tasks['build-UbuntuServer16.04.4_amd64-amazon'].dependsOn 'createManifestOutputDir'
tasks['build-UbuntuServer16.04.4_amd64'].dependsOn 'createManifestOutputDir'

task('clean-base') {
  group 'Build'
  dependsOn 'clean-UbuntuServer16.04.4_amd64'
}

task('clean') {
  dependsOn 'clean-base', 'clean-JenkinsSlaves', 'clean-JenkinsMaster'
}

task('build-base-vbox') {
  group 'Build'
  dependsOn 'build-UbuntuServer16.04.4_amd64-vbox'
}

task('build-base-amazon') {
  group 'Build'
  dependsOn 'build-UbuntuServer16.04.4_amd64-amazon'
}

task('build-base') {
  group 'Build'
  dependsOn 'build-UbuntuServer16.04.4_amd64'
}

task('berksUpdate') {
  doLast {
    berksUpdate()
  }
}

task('berksVerify') {
  inputs.file berksfile
  doLast {
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'verify'
        ] +
        berksLogLevelArgs
      )
    }
  }
}

task('berksClean', type: Delete) {
  delete berksVendorDir
}

task('berksVendor') {
  dependsOn 'berksClean', 'berksUpdate'
  mustRunAfter 'berksVerify'
  inputs.file berksfileLock
  doLast {
    exec {
      workingDir chefDir
      commandLine(
        [
          bundleExecutable, 'exec'
        ] +
        bundleLogLevelArgs +
        [
          'berks', 'vendor',
          berksVendorDir.absolutePath
        ] +
        berksLogLevelArgs
      )
    }
  }
  outputs.dir berksVendorDir
}

task('kitchenTest-BuildToolkit', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common', 'berksUpdate'
  mustRunAfter 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'test',
      'BuildToolkit',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-BuildToolkit', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common'
  mustRunAfter 'berksUpdate', 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'converge',
      'BuildToolkit',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenLogin-BuildToolkit') {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common'
  mustRunAfter 'kitchenConverge-BuildToolkit'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'BuildToolkit',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenVerify-BuildToolkit', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common', 'kitchenConverge-BuildToolkit'
  mustRunAfter 'berksUpdate', 'build-base', 'build-base-amazon'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'verify',
      'BuildToolkit',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-BuildToolkit', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'BuildToolkit',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

tasks['build-JenkinsSlaves'].with {
  dependsOn 'createManifestOutputDir', 'terraformApply-common', 'terraformOutput-common', 'berksVendor'
  mustRunAfter 'build-base', 'build-base-amazon', 'kitchenTest-BuildToolkit', 'kitchenConverge-BuildToolkit'
}

task('generateRuntimeDataBag') {
  dependsOn 'terraformOutput-common', 'generateSSHKey-FIDATAChef', 'generateSSHKey-FIDATAJenkins'
  mustRunAfter 'build-JenkinsSlaves'
  inputs.with {
    file encryptedDataBagSecret
    property 'FIDATAChefDataBag', {
      dataBags['FIDATAChef'] << [
        'username': fidataChefUsername,
        'full_name': fidataChefFullName,
        'email': fidataChefEmail,
        'public_key': tasks['generateSSHKey-FIDATAChef'].publicKeyFile.text,
        'private_key': tasks['generateSSHKey-FIDATAChef'].privateKeyFile.text,
        'jenkins': [
          'password': fidataChefJenkinsPassword,
        ],
      ]
    }
    property 'FIDATAJenkinsDataBag', {
      dataBags['FIDATAJenkins'] << [
        'username': fidataJenkinsUsername,
        'full_name': fidataJenkinsFullName,
        'email': fidataJenkinsEmail,
        'public_key': tasks['generateSSHKey-FIDATAJenkins'].publicKeyFile.text,
        'private_key': tasks['generateSSHKey-FIDATAJenkins'].privateKeyFile.text,
        'yandex': [
          'username': fidataJenkinsYandexUsername,
          'password': fidataJenkinsYandexPassword,
        ],
        'github': [
          'token': fidataJenkinsGithubToken,
        ],
        'artifactory': [
          'api_key': fidataJenkinsArtifactoryAPIKey,
        ],
        'bintray': [
          'api_key': fidataJenkinsBintrayAPIKey,
        ],
        'aws_iam': [
          'access_key': terraformOutputs['fidata_jenkins_iam_access_key']['value'],
          'secret_key': terraformOutputs['fidata_jenkins_iam_secret_key']['value'],
        ],
      ]
    }
    property 'JenkinsGithubOAuthDataBag', {
      dataBags['JenkinsGithubOAuth'] << [
        'client_id': jenkinsGithubOAuthClientID,
        'client_secret': jenkinsGithubOAuthClientSecret,
      ]
    }
    property 'JenkinsEC2CloudDataBag', {
      for (s in jenkinsSlaves) {
        s.value['ami'] = getAtlasArtifactMetadataFull("fidata/JenkinsSlave-${s.key.replace('+', '_')}", 'amazon.image', s.value['version'])['ami_id']
      }
      dataBags['JenkinsEC2Cloud'] << [
        'region': 'eu-west-1',
        'zone': 'eu-west-1c',
        'subnet_id': terraformOutputs['fidata_subnet_id']['value'],
        'slaves': jenkinsSlaves,
      ]
    }
    property 'ReleaseCredentialsDataBag', {
      dataBags['ReleaseCredentials'] << [
        'rubygems': [
          'api_key': rubygemsAPIKey,
        ],
        'pypi': [
          'username': pypiUsername,
          'password': pypiPassword,
        ],
        'gradle_plugins': [
          'key': gradlePluginsKey,
          'secret': gradlePluginsSecret,
        ],
        'chocolatey': [
          'api_key': chocolateyAPIKey,
        ],
        'chef_id': [
          'private_key': chefIdPrivateKey.text,
        ],
      ]
    }
  }

  doLast {
    for (dataBag in dataBags) {
      exec {
        workingDir chefDir
        commandLine(
          [
            bundleExecutable, 'exec'
          ] +
          bundleLogLevelArgs +
          [
            'knife', 'solo', 'data', 'bag', 'create',
            'runtime', dataBag.key,
            '--secret-file', encryptedDataBagSecret,
            '--json', JsonOutput.toJson(
              ['id': dataBag.key] +
              dataBag.value
            ).replace('"', OperatingSystem.current().windows ? '\\"' : '"')
          ] +
          knifeLogLevelArgs
        )
      }
    }
  }

  for (dataBag in dataBags) {
    outputs.file "$chefDir/data_bags/runtime/${dataBag.key}.json"
  }
}

task('kitchenTest-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common', 'generateRuntimeDataBag', 'berksUpdate'
  mustRunAfter 'build-UbuntuServer16.04.4_amd64-vbox'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'test',
      'JenkinsMaster-vbox',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenTest-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common', 'generateRuntimeDataBag', 'berksUpdate'
  mustRunAfter 'build-UbuntuServer16.04.4_amd64-amazon', 'build-UbuntuServer16.04.4_amd64'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'test',
      'JenkinsMaster-amazon',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common', 'generateRuntimeDataBag'
  mustRunAfter 'berksUpdate', 'build-UbuntuServer16.04.4_amd64-vbox'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'converge',
      'JenkinsMaster-vbox',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenConverge-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformApply-common', 'terraformOutput-common', 'generateRuntimeDataBag'
  mustRunAfter 'berksUpdate', 'build-UbuntuServer16.04.4_amd64-amazon', 'build-UbuntuServer16.04.4_amd64'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'converge',
      'JenkinsMaster-amazon',
      '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenLogin-JenkinsMaster-vbox') {
  group 'Test'
  dependsOn 'terraformOutput-common'
  mustRunAfter 'kitchenConverge-JenkinsMaster-vbox'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'JenkinsMaster-vbox',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenLogin-JenkinsMaster-amazon') {
  group 'Test'
  dependsOn 'terraformOutput-common'
  mustRunAfter 'kitchenConverge-JenkinsMaster-amazon'
  doLast {
    CommandLine cmdLine = new CommandLine(consoleExecutable).addArguments((
      consoleArgs +
      [
        bundleExecutable, 'exec'
      ] +
      bundleLogLevelArgs + [
        'kitchen', 'login',
        'JenkinsMaster-amazon',
        '--no-log-overwrite'
      ] +
      kitchenLogLevelArgs
    ) as String[])
    Executor executor = new DefaultExecutor()
    executor.workingDirectory = chefDir
    executor.execute(cmdLine, new HashMap(System.env) + kitchenEnvironment)
  }
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-JenkinsMaster-vbox', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'JenkinsMaster-vbox',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

task('kitchenDestroy-JenkinsMaster-amazon', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common'
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs +
    [
      'kitchen', 'destroy',
      'JenkinsMaster-amazon',
      '-c', '--no-log-overwrite'
    ] +
    kitchenLogLevelArgs
  )
  outputs.upToDateWhen { false }
}

tasks['build-JenkinsMaster'].with {
  dependsOn 'createManifestOutputDir', 'terraformApply-common', 'terraformOutput-common', 'generateRuntimeDataBag', 'berksVendor'
  mustRunAfter 'build-UbuntuServer16.04.4_amd64-amazon', 'build-UbuntuServer16.04.4_amd64', 'kitchenTest-JenkinsMaster-vbox', 'kitchenConverge-JenkinsMaster-vbox', 'kitchenTest-JenkinsMaster-amazon', 'kitchenConverge-JenkinsMaster-amazon'
}

task('terraformValidate-instances', type: Exec) {
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  workingDir "$terraformDir/instances"
  environment << terraformEnvironment
  commandLine(
    [
      'terraform', 'validate'
    ] +
    terraformVariablesForArgs
  )
}

task('terraformDestroy-instances') {
  mustRunAfter 'terraformValidate-instances'
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  File stateFile = file("$terraformOutputDir/instances.tfstate")
  doLast {
    exec {
      workingDir "$terraformDir/instances"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'destroy',
          "-state=${stateFile.absolutePath}",
          '-force',
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
  outputs.file stateFile
}

task('terraformApply-instances') {
  group 'Build'
  mustRunAfter 'terraformValidate-instances', 'terraformDestroy-instances', 'build-JenkinsMaster'
  inputs.property 'terraformVariablesForArgs', terraformVariablesForArgs
  inputs.files new FileNameFinder().getFileNames("$terraformDir/instances", '*.tf *.tf.json')
  File stateFile = file("$terraformOutputDir/instances.tfstate")
  doLast {
    exec {
      workingDir "$terraformDir/instances"
      environment << terraformEnvironment
      commandLine(
        [
          'terraform', 'apply',
          '-input=false',
          "-state=${stateFile.absolutePath}",
          '-lock=true'
        ] +
        terraformVariablesForArgs
      )
    }
  }
  outputs.file stateFile
  outputs.upToDateWhen { false }
}

task('codenarc', type: CodeNarc) {
  group 'Test'
  source 'Jenkinsfile'
  source 'build.gradle'
  for (f in new FileNameFinder().getFileNames(projectDir.path, '**/*.groovy')) {
    source f
  }
  configFile = file('config/codenarc/codenarc.groovy')
  reports {
    xml {
      enabled = true
      destination = codenarcXMLOutput
    }
    console { enabled = true }
    html {
      enabled = true
      destination = codenarcHTMLOutput
    }
  }
}

task('kitchenDiagnose', type: CrossPlatformExec) {
  group 'Test'
  dependsOn 'terraformOutput-common'
  outputs.upToDateWhen { false }
  workingDir chefDir
  doFirst {
    environment << kitchenEnvironment
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'kitchen', 'diagnose',
      '--no-instances', '--all'
    ] +
    kitchenLogLevelArgs
  )
}

task('rubocop', type: CrossPlatformExec) {
  group 'Test'
  List<File> sourceFiles = [gemfile, libDir] + (new FileNameFinder().getFileNames(chefDir.path, '**/*.rb', 'cookbooks/**/* site-cookbooks/**/* environments/**/*')).collect { file(it) }
  for (f in sourceFiles) {
    inputs.with {
      if (f.isDirectory()) {
        files new FileNameFinder().getFileNames(f.path, '**/*.rb')
      }
      else {
        file f
      }
    }
  }
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'rubocop',
      '--display-cop-names',
      '--require', 'rubocop/formatter/checkstyle_formatter',
      '--format', 'RuboCop::Formatter::CheckstyleFormatter', '--out', rubocopCheckstyleOutput.absolutePath,
      '--format', 'progress',
      '--format', 'html', '--out', rubocopHTMLOutput.absolutePath
    ] +
    sourceFiles
  )
  outputs.file rubocopCheckstyleOutput
  outputs.file rubocopHTMLOutput
}

task('foodcritic', type: CrossPlatformExec) {
  group 'Test'
  inputs.with {
    dir "$chefDir/cookbooks"
    dir "$chefDir/site-cookbooks"
    dir "$chefDir/environments"
  }
  workingDir chefDir
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'foodcritic',
      '--cookbook-path', 'cookbooks', 'site-cookbooks',
      '--environment-path', 'environments'
    ]
  )
}

task('cookstyle', type: CrossPlatformExec) {
  group 'Test'
  inputs.dir chefDir
  workingDir chefDir
  commandLine(
    [
      'bundle', 'exec'
    ] +
    bundleLogLevelArgs + [
      'cookstyle',
      '--display-cop-names',
      '--require', 'rubocop/formatter/checkstyle_formatter',
      '--format', 'RuboCop::Formatter::CheckstyleFormatter', '--out', cookstyleCheckstyleOutput.absolutePath,
      '--format', 'progress',
      '--format', 'html', '--out', cookstyleHTMLOutput.absolutePath
    ]
  )
  outputs.file cookstyleCheckstyleOutput
  outputs.file cookstyleHTMLOutput
}

task('check-noSideEffects') {
  group 'Test'
  dependsOn 'codenarc', 'bundleDoctor', 'pipenvCheck', 'berksVerify', 'validate', 'rubocop', 'foodcritic', 'cookstyle', 'terraformValidate-common', 'terraformValidate-instances'
}

/* CAVEAT:
 * kitchenDiagnose depends on terraformCommon-apply task
 * So we treat it separately <> */
task('check') {
  group 'Test'
  dependsOn 'check-noSideEffects', 'kitchenDiagnose'
}

task('deploy') {
  group 'Build'
  dependsOn 'terraformApply-instances'
}

task('inputsOutputs').doLast {
  for (t in tasks) {
    if (t.inputs.hasInputs) {
      for (f in t.inputs.files) {
        logger.lifecycle(sprintf('%s input:\t%s', [t.name, f.path]))
      }
    }
    if (t.outputs.hasOutput) {
      for (f in t.outputs.files) {
        logger.lifecycle(sprintf('%s output:\t%s', [t.name, f.path]))
      }
    }
  }
}
